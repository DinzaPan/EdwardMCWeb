// Datos de ejemplo para los addons
const addonsData = [
    {
        id: 1,
        title: "Actions & Stuff",
        description: "Esta Textura Mejora Tu Mundo Con Animaciones Espectaculares Facil De Activar",
        cover_image: "./img/Action.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/g37g",
        tags: ["Texturas", "Animaci√≥n", "Golem Animado"],
        last_updated: "2025-10-6",
        file_size: "16.97 MB"
    },
    {
        id: 2,
        title: "$minecraft Custom Command V6.4",
        description: "üåü¬°üéÉDescubre Command Personalizados Para Tu Servidor De Minecraft Bedrock Variedad de Comandos Personalizados Para Que Sea F√°cil Hacerte Tp Hacia Otros Lobby Etc.üöÄüåç „Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§‚û°Ô∏èüéÉComo Funciona Este Addon Es F√°cil Al Implementar El Addon A Tu Mundo o Servidor Verifique !help Con este Comand Si Le Funciona Tambi√©n Puede Hacerte Tp Como Con El !lobby Como Modificar Las Coordenada ? F√°cil Llendo Alos Archivo Del Addon Script y Depues En index.js Tutorial Completo En Mi Canal De Youtube : Edward Gamer Addon",
        cover_image: "./img/Commd.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/fNeu4l",
        tags: ["custom", "command", "personalizado"],
        last_updated: "2025-10-5",
        file_size: "196.89 KB"
    },
    {
        id: 3,
        title: "Welcome System V3.7",
        description: "üéÜüéÉBienvenido al Addon Welcome System. Dale la bienvenida a tus amigos y jugadores con un sistema. Al unirse a tu mundo, Recibir√°n Una Bienvenida Perfecto Para Tu Servidor De Minecraft Bedrock. „Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§‚û°Ô∏èComo Modificar El Script Para Que Sea A Tu Gusto Valla Al Los Archivos Del Addon En Script y Depues En main.js Sino Saves Como En Mi Canal De Youtube Esta El Tuturial YT : Edward Gamer Addon.",
        cover_image: "./img/Welcome.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/slCCvU",
        tags: ["Bienvenida", "Mensaje", "servidores"],
        last_updated: "2025-10-5",
        file_size: "207.97 KB"
    },
    {
        id: 4,
        title: "Shop UI V1.5",
        description: "üè´!üéÉA√±ade una Tienda a Tu Servidor de Minecraft que te Permite Comprar items en Menu UI incre√≠ble, Creador Y Creditos Edward Gamer : Cappytqm28.„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§ „Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§‚û°Ô∏èüéÉEste Addon Se  Abre Con El Item Reloj o Clock üß≠ Tambi√©n Se Puede Abrir Escribiendo Esto En El Chat .Shop o .shop Recuerda A√±adirte Un Scoreboard a√±adiendo Dinero Si Quieres El Tutorial Completo en Mi Canal De Youtube : Edward Gamer Addon",
        cover_image: "./img/ShopUI.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/WeeFetphDuKo",
        tags: ["Tienda", "Dinero", "Menu UI"],
        last_updated: "2025-10-5",
        file_size: "139.31 KB" 
    },
    {
        id: 5,
        title: "Login Registre V5.3",
        description: "‚ú®!üéÉEste addon a√±ade una UI o un sistema que ara que los jugadores al momento de entrar al mundo deben registrarse poniendo nombre de Usuario y Contrase√±a Para Completar El Registro Si no quieren registrarse los usuarios no podran acceder.„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§üìõüéÉYa C√∫ando Se Aya Registrado Y Termine De Jugar En El Server Cuando se salgan y Vuelvan a Entrar Al Servidor tendar√°n que iniciar sesi√≥n con su nombre de usuario y contrase√±a.„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§ „Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§‚ö†Ô∏èüéÉImportantes No Olvides Tu Nombre De Usuario Y Contrase√±a.",
        cover_image: "./img/Registre.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/IilYSoH4TtS",
        tags: ["Login", "Registre", "Seguridad"],
        last_updated: "2025-10-5",
        file_size: "2.16 MB"
    },
    {
        id: 6,
        title: "Rank Chat V9.4",
        description: "‚öúÔ∏è!üéÉRango chat Para Minecraft Bedrock Se A√±adi√≥ Un Menu UI Par√° Manejar El Systema De Rango En El Chat Con Facilidad El Menu Solamente Puede Ingresar Los Administradores Con Un Tag : „Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§ üóÇÔ∏èüéÉ√öltimo Agregado : Se A√±adi√≥ Un Item Custom Qu√© Solo Se Puede Sacar del Creativo Y Abrilo Es Obligatorio A√±adirte Un Tag /tag @s add Admin !",
        cover_image: "./img/Rango.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/Wlpks",
        tags: ["Rangos", "Menu UI", "Servidores"],
        last_updated: "2025-10-5",
        file_size: "360.04 KB"
    },
    {
        id: 7,
        title: "Men√∫ Warp V9.9",
        description: "üî∞!üéÉSe Arreglaron Bug Este a√±ade un Menu Warp con el que podras tener varias opciones para tu Realm Y Tu Servidor Puedes a√±adir este Menu Warp para utilizar varias opciones como las Warp, Clanes, Bank, Sethome, Trabajos entre otras opciones mas que puedes modificar en el > Confi < Descarga el Addon Aqui.",
        cover_image: "./img/MenuWarp.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/He9nBZqB7mEA",
        tags: ["Menu UI", "Banco", "Perfil", "Clanes","Trabajo"],
        last_updated: "2025-10-5",
        file_size: "312.11 KB"
    },
    {
        id: 8,
        title: "$1 Custom NPC V4.4",
        description: "‚öôÔ∏è!üéÉCustomNPC Para Minecraft Bedrock Funciona Perfecto y tine Varios Utilidades, Este addon de NPC Custom puede ayudarte en tu servidor de Minecraft y puedes encontrar utilidades y la forma de editar y personalizar estos NPC para tu servidor de Minecraft o Realm o simplemente para tu servidor.",
        cover_image: "./img/Npc.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/FQcTTU",
        tags: ["Npc", "Custom", "Addon"],
        last_updated: "2025-10-5",
        file_size: "1 MB"
    }
];

// Configuraci√≥n de JSONBin.io - TUS CREDENCIALES
const JSONBIN_BASE_URL = "https://api.jsonbin.io/v3/b";
const BIN_ID = "68e3f94dd0ea881f40978bff";
const MASTER_KEY = "$2a$10$llDNWie9.N2CafYjo7o3.OB/8XZpTocfzmyU2gCwG/bJGYAThWYyC";

// Configuraci√≥n del sistema de cache
const CACHE_CONFIG = {
    REVIEWS_CACHE_KEY: 'edwardmc_reviews_cache',
    CACHE_TIMESTAMP_KEY: 'edwardmc_cache_timestamp',
    CACHE_DURATION: 5 * 60 * 1000, // 5 minutos en milisegundos
    PENDING_REVIEWS_KEY: 'edwardmc_pending_reviews'
};

// Sistema de cache para rese√±as
class ReviewsCache {
    constructor() {
        this.isOnline = true;
        this.pendingSync = this.getPendingReviews();
        this.init();
    }

    init() {
        // Verificar conexi√≥n
        this.checkConnection();
        // Sincronizar pendientes al cargar
        this.syncPendingReviews();
    }

    // Verificar si el cache est√° vigente
    isCacheValid() {
        const timestamp = localStorage.getItem(CACHE_CONFIG.CACHE_TIMESTAMP_KEY);
        if (!timestamp) return false;
        
        const now = Date.now();
        const cacheTime = parseInt(timestamp);
        return (now - cacheTime) < CACHE_CONFIG.CACHE_DURATION;
    }

    // Guardar rese√±as en cache
    saveToCache(reviews) {
        try {
            localStorage.setItem(CACHE_CONFIG.REVIEWS_CACHE_KEY, JSON.stringify(reviews));
            localStorage.setItem(CACHE_CONFIG.CACHE_TIMESTAMP_KEY, Date.now().toString());
            console.log('Rese√±as guardadas en cache local');
        } catch (error) {
            console.error('Error guardando en cache:', error);
        }
    }

    // Obtener rese√±as del cache
    getFromCache() {
        try {
            const cached = localStorage.getItem(CACHE_CONFIG.REVIEWS_CACHE_KEY);
            return cached ? JSON.parse(cached) : null;
        } catch (error) {
            console.error('Error obteniendo del cache:', error);
            return null;
        }
    }

    // Guardar rese√±a pendiente de sincronizaci√≥n
    savePendingReview(addonId, rating, comment) {
        const pending = this.getPendingReviews();
        const review = {
            addonId,
            rating,
            comment,
            timestamp: new Date().toISOString(),
            userId: getUserId()
        };
        
        pending.push(review);
        localStorage.setItem(CACHE_CONFIG.PENDING_REVIEWS_KEY, JSON.stringify(pending));
        return review;
    }

    // Obtener rese√±as pendientes
    getPendingReviews() {
        try {
            const pending = localStorage.getItem(CACHE_CONFIG.PENDING_REVIEWS_KEY);
            return pending ? JSON.parse(pending) : [];
        } catch (error) {
            console.error('Error obteniendo rese√±as pendientes:', error);
            return [];
        }
    }

    // Limpiar rese√±as pendientes
    clearPendingReviews() {
        localStorage.removeItem(CACHE_CONFIG.PENDING_REVIEWS_KEY);
    }

    // Sincronizar rese√±as pendientes con JSONBin
    async syncPendingReviews() {
        const pending = this.getPendingReviews();
        if (pending.length === 0 || !this.isOnline) return;

        console.log(`Sincronizando ${pending.length} rese√±as pendientes...`);
        
        for (const review of pending) {
            try {
                await this.syncSingleReview(review);
            } catch (error) {
                console.error('Error sincronizando rese√±a:', error);
                break; // Si falla una, paramos para no perder las dem√°s
            }
        }

        // Actualizar cache despu√©s de sincronizar
        await this.fetchAndUpdateCache();
    }

    // Sincronizar una sola rese√±a
    async syncSingleReview(review) {
        const reviews = await this.fetchReviewsFromAPI();
        
        if (!reviews[review.addonId]) {
            reviews[review.addonId] = [];
        }

        const existingIndex = reviews[review.addonId].findIndex(r => r.userId === review.userId);
        
        if (existingIndex !== -1) {
            reviews[review.addonId][existingIndex] = {
                userId: review.userId,
                rating: review.rating,
                comment: review.comment,
                timestamp: review.timestamp
            };
        } else {
            reviews[review.addonId].push({
                userId: review.userId,
                rating: review.rating,
                comment: review.comment,
                timestamp: review.timestamp
            });
        }

        await this.saveReviewsToAPI(reviews);
    }

    // Verificar conexi√≥n a internet
    checkConnection() {
        this.isOnline = navigator.onLine;
        
        // Escuchar cambios en la conexi√≥n
        window.addEventListener('online', () => {
            this.isOnline = true;
            this.syncPendingReviews();
        });
        
        window.addEventListener('offline', () => {
            this.isOnline = false;
        });
    }

    // Obtener rese√±as (con cache)
    async getReviews() {
        // Primero intentar con cache v√°lido
        if (this.isCacheValid()) {
            const cached = this.getFromCache();
            if (cached) {
                console.log('Usando rese√±as desde cache local');
                return cached;
            }
        }

        // Si no hay cache v√°lido, obtener de API
        return await this.fetchAndUpdateCache();
    }

    // Obtener rese√±as desde API y actualizar cache
    async fetchAndUpdateCache() {
        try {
            const reviews = await this.fetchReviewsFromAPI();
            this.saveToCache(reviews);
            console.log('Rese√±as actualizadas desde JSONBin');
            return reviews;
        } catch (error) {
            console.error('Error obteniendo rese√±as:', error);
            // Si falla la API, usar cache aunque sea viejo
            const cached = this.getFromCache();
            if (cached) {
                console.log('Usando cache antiguo por fallo de conexi√≥n');
                return cached;
            }
            throw error;
        }
    }

    // Obtener rese√±as desde JSONBin
    async fetchReviewsFromAPI() {
        const response = await fetch(`${JSONBIN_BASE_URL}/${BIN_ID}/latest`, {
            headers: {
                'X-Master-Key': MASTER_KEY,
                'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) {
            throw new Error('Error al cargar las rese√±as desde JSONBin');
        }
        
        const data = await response.json();
        return data.record || this.getDefaultReviewsStructure();
    }

    // Guardar rese√±as en JSONBin
    async saveReviewsToAPI(reviews) {
        const response = await fetch(`${JSONBIN_BASE_URL}/${BIN_ID}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-Master-Key': MASTER_KEY
            },
            body: JSON.stringify(reviews)
        });
        
        if (!response.ok) {
            throw new Error('Error al guardar las rese√±as en JSONBin');
        }
        
        return await response.json();
    }

    // Estructura por defecto para rese√±as
    getDefaultReviewsStructure() {
        return {
            "1": [],
            "2": [],
            "3": [],
            "4": [],
            "5": [],
            "6": [],
            "7": [],
            "8": []
        };
    }
}

// Instancia global del cache
const reviewsCache = new ReviewsCache();

// Sistema de carga
function showLoading() {
    const loadingOverlay = document.getElementById('loadingOverlay');
    if (loadingOverlay) {
        loadingOverlay.classList.remove('hidden');
    }
}

function hideLoading() {
    const loadingOverlay = document.getElementById('loadingOverlay');
    if (loadingOverlay) {
        setTimeout(() => {
            loadingOverlay.classList.add('hidden');
        }, 1000);
    }
}

// Funci√≥n para obtener un addon por ID
function getAddonById(id) {
    return addonsData.find(addon => addon.id === parseInt(id));
}

// Funci√≥n para obtener todos los addons
function getAllAddons() {
    return addonsData;
}

// Funci√≥n para buscar addons
function searchAddons(query) {
    if (!query) {
        return addonsData;
    }
    
    const lowerQuery = query.toLowerCase();
    return addonsData.filter(addon => 
        addon.title.toLowerCase().includes(lowerQuery) ||
        addon.description.toLowerCase().includes(lowerQuery) ||
        addon.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
    );
}

// Funci√≥n para formatear fechas
function formatDate(dateString) {
    const options = { year: 'numeric', month: 'long', day: 'numeric' };
    return new Date(dateString).toLocaleDateString('es-ES', options);
}

// Sistema de rese√±as (ACTUALIZADO con cache)
async function fetchReviews() {
    return await reviewsCache.getReviews();
}

async function saveReviews(reviews) {
    try {
        await reviewsCache.saveReviewsToAPI(reviews);
        reviewsCache.saveToCache(reviews); // Actualizar cache local
        return reviews;
    } catch (error) {
        console.error('Error al guardar rese√±as:', error);
        throw error;
    }
}

// Obtener rese√±as de un addon espec√≠fico
async function getReviewsForAddon(addonId) {
    const reviews = await fetchReviews();
    return reviews[addonId] || [];
}

// Obtener rese√±a del usuario actual para un addon
async function getUserReviewForAddon(addonId) {
    const reviews = await getReviewsForAddon(addonId);
    const userId = getUserId();
    
    // Tambi√©n verificar en rese√±as pendientes
    const pending = reviewsCache.getPendingReviews();
    const pendingReview = pending.find(review => 
        review.addonId === addonId.toString() && review.userId === userId
    );
    
    if (pendingReview) {
        return {
            userId: pendingReview.userId,
            rating: pendingReview.rating,
            comment: pendingReview.comment,
            timestamp: pendingReview.timestamp,
            pending: true
        };
    }
    
    return reviews.find(review => review.userId === userId);
}

// A√±adir o actualizar rese√±a (ACTUALIZADA con sistema de cache)
async function addOrUpdateReview(addonId, rating, comment) {
    const userId = getUserId();
    
    if (reviewsCache.isOnline) {
        // Si hay conexi√≥n, guardar directamente en JSONBin
        const reviews = await fetchReviews();
        
        if (!reviews[addonId]) {
            reviews[addonId] = [];
        }
        
        const existingReviewIndex = reviews[addonId].findIndex(review => review.userId === userId);
        
        if (existingReviewIndex !== -1) {
            reviews[addonId][existingReviewIndex] = {
                userId,
                rating,
                comment,
                timestamp: new Date().toISOString()
            };
        } else {
            reviews[addonId].push({
                userId,
                rating,
                comment,
                timestamp: new Date().toISOString()
            });
        }
        
        await saveReviews(reviews);
        return reviews[addonId];
    } else {
        // Sin conexi√≥n, guardar en cache local como pendiente
        console.log('Sin conexi√≥n, guardando rese√±a en cache local');
        reviewsCache.savePendingReview(addonId.toString(), rating, comment);
        
        // Actualizar cache local para reflejar el cambio inmediatamente
        const cachedReviews = reviewsCache.getFromCache() || reviewsCache.getDefaultReviewsStructure();
        if (!cachedReviews[addonId]) {
            cachedReviews[addonId] = [];
        }
        
        const existingIndex = cachedReviews[addonId].findIndex(review => review.userId === userId);
        
        if (existingIndex !== -1) {
            cachedReviews[addonId][existingIndex] = {
                userId,
                rating,
                comment,
                timestamp: new Date().toISOString()
            };
        } else {
            cachedReviews[addonId].push({
                userId,
                rating,
                comment,
                timestamp: new Date().toISOString()
            });
        }
        
        reviewsCache.saveToCache(cachedReviews);
        return cachedReviews[addonId];
    }
}

// Eliminar rese√±a (ACTUALIZADA con sistema de cache)
async function deleteReview(addonId) {
    const userId = getUserId();
    
    if (reviewsCache.isOnline) {
        const reviews = await fetchReviews();
        
        if (reviews[addonId]) {
            reviews[addonId] = reviews[addonId].filter(review => review.userId !== userId);
            await saveReviews(reviews);
        }
        
        return reviews[addonId] || [];
    } else {
        // Sin conexi√≥n, eliminar de cache local
        console.log('Sin conexi√≥n, eliminando rese√±a del cache local');
        
        // Eliminar de pendientes
        const pending = reviewsCache.getPendingReviews().filter(review => 
            !(review.addonId === addonId.toString() && review.userId === userId)
        );
        localStorage.setItem(CACHE_CONFIG.PENDING_REVIEWS_KEY, JSON.stringify(pending));
        
        // Actualizar cache local
        const cachedReviews = reviewsCache.getFromCache() || reviewsCache.getDefaultReviewsStructure();
        if (cachedReviews[addonId]) {
            cachedReviews[addonId] = cachedReviews[addonId].filter(review => review.userId !== userId);
            reviewsCache.saveToCache(cachedReviews);
        }
        
        return cachedReviews[addonId] || [];
    }
}

// Forzar sincronizaci√≥n de rese√±as
async function forceSyncReviews() {
    if (!reviewsCache.isOnline) {
        console.log('No hay conexi√≥n para sincronizar');
        return false;
    }
    
    try {
        await reviewsCache.syncPendingReviews();
        reviewsCache.clearPendingReviews();
        console.log('Sincronizaci√≥n completada');
        return true;
    } catch (error) {
        console.error('Error en sincronizaci√≥n:', error);
        return false;
    }
}

// Calcular promedio de calificaciones
function calculateAverageRating(reviews) {
    if (!reviews || reviews.length === 0) return 0;
    
    const sum = reviews.reduce((total, review) => total + review.rating, 0);
    return (sum / reviews.length).toFixed(1);
}

// Generar ID √∫nico para usuario (simulado)
function getUserId() {
    let userId = localStorage.getItem('edwardmc_userId');
    if (!userId) {
        userId = 'user_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('edwardmc_userId', userId);
    }
    return userId;
}

// Renderizar estrellas
function renderStars(rating, interactive = false, size = 'medium') {
    const starSize = size === 'small' ? '1rem' : '1.5rem';
    let starsHtml = '';
    
    for (let i = 1; i <= 5; i++) {
        if (interactive) {
            starsHtml += `
                <span class="star ${i <= rating ? 'active' : ''}" data-rating="${i}">
                    <svg xmlns="http://www.w3.org/2000/svg" width="${starSize}" height="${starSize}" viewBox="0 0 24 24" fill="${i <= rating ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                    </svg>
                </span>
            `;
        } else {
            starsHtml += `
                <span class="star ${i <= rating ? 'active' : ''}">
                    <svg xmlns="http://www.w3.org/2000/svg" width="${starSize}" height="${starSize}" viewBox="0 0 24 24" fill="${i <= rating ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                    </svg>
                </span>
            `;
        }
    }
    
    return `<div class="stars ${interactive ? 'interactive' : ''} ${size}">${starsHtml}</div>`;
}

// Funci√≥n para obtener foto de perfil del usuario
function getUserProfilePicture() {
    return "./img/profile/p1.jpg";
}

// Funci√≥n para procesar texto con stickers (compatibilidad)
function processTextWithStickers(text) {
    if (typeof window.StickerSystem !== 'undefined') {
        return window.StickerSystem.processStickers(text);
    }
    return text;
}

// Funci√≥n para procesar texto con stickers en t√≠tulos (compatibilidad)
function processTextWithStickersInTitles(text) {
    if (typeof window.StickerSystem !== 'undefined') {
        return window.StickerSystem.processStickersInTitles(text);
    }
    return text;
}

// Sincronizar autom√°ticamente al cargar la p√°gina si hay conexi√≥n
document.addEventListener('DOMContentLoaded', function() {
    if (reviewsCache.isOnline) {
        // Sincronizar pendientes despu√©s de 2 segundos
        setTimeout(() => {
            reviewsCache.syncPendingReviews();
        }, 2000);
    }
    
    // Mostrar estado de conexi√≥n en consola
    console.log(`Estado conexi√≥n: ${reviewsCache.isOnline ? 'En l√≠nea' : 'Sin conexi√≥n'}`);
    
    const pending = reviewsCache.getPendingReviews();
    if (pending.length > 0) {
        console.log(`${pending.length} rese√±as pendientes de sincronizaci√≥n`);
    }
});
