// Datos de ejemplo para los addons
const addonsData = [
    {
        id: 1,
        title: "Actions & Stuff",
        description: "Esta Textura Mejora Tu Mundo Con Animaciones Espectaculares Facil De Activar",
        cover_image: "./img/Action.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/g37g",
        tags: ["Texturas", "Animación", "Golem Animado"],
        last_updated: "2025-10-6",
        file_size: "16.97 MB"
    },
    {
        id: 2,
        title: "$minecraft Custom Command V6.4",
        description: "🌟¡🎃Descubre Command Personalizados Para Tu Servidor De Minecraft Bedrock Variedad de Comandos Personalizados Para Que Sea Fácil Hacerte Tp Hacia Otros Lobby Etc.🚀🌍 ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ➡️🎃Como Funciona Este Addon Es Fácil Al Implementar El Addon A Tu Mundo o Servidor Verifique !help Con este Comand Si Le Funciona También Puede Hacerte Tp Como Con El !lobby Como Modificar Las Coordenada ? Fácil Llendo Alos Archivo Del Addon Script y Depues En index.js Tutorial Completo En Mi Canal De Youtube : Edward Gamer Addon",
        cover_image: "./img/Commd.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/fNeu4l",
        tags: ["custom", "command", "personalizado"],
        last_updated: "2025-10-5",
        file_size: "196.89 KB"
    },
    {
        id: 3,
        title: "Welcome System V3.7",
        description: "🎆🎃Bienvenido al Addon Welcome System. Dale la bienvenida a tus amigos y jugadores con un sistema. Al unirse a tu mundo, Recibirán Una Bienvenida Perfecto Para Tu Servidor De Minecraft Bedrock. ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ➡️Como Modificar El Script Para Que Sea A Tu Gusto Valla Al Los Archivos Del Addon En Script y Depues En main.js Sino Saves Como En Mi Canal De Youtube Esta El Tuturial YT : Edward Gamer Addon.",
        cover_image: "./img/Welcome.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/slCCvU",
        tags: ["Bienvenida", "Mensaje", "servidores"],
        last_updated: "2025-10-5",
        file_size: "207.97 KB"
    },
    {
        id: 4,
        title: "Shop UI V1.5",
        description: "🏫!🎃Añade una Tienda a Tu Servidor de Minecraft que te Permite Comprar items en Menu UI increíble, Creador Y Creditos Edward Gamer : Cappytqm28.ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ ㅤㅤㅤㅤㅤㅤㅤㅤㅤ➡️🎃Este Addon Se  Abre Con El Item Reloj o Clock 🧭 También Se Puede Abrir Escribiendo Esto En El Chat .Shop o .shop Recuerda Añadirte Un Scoreboard añadiendo Dinero Si Quieres El Tutorial Completo en Mi Canal De Youtube : Edward Gamer Addon",
        cover_image: "./img/ShopUI.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/WeeFetphDuKo",
        tags: ["Tienda", "Dinero", "Menu UI"],
        last_updated: "2025-10-5",
        file_size: "139.31 KB" 
    },
    {
        id: 5,
        title: "Login Registre V5.3",
        description: "✨!🎃Este addon añade una UI o un sistema que ara que los jugadores al momento de entrar al mundo deben registrarse poniendo nombre de Usuario y Contraseña Para Completar El Registro Si no quieren registrarse los usuarios no podran acceder.ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ📛🎃Ya Cúando Se Aya Registrado Y Termine De Jugar En El Server Cuando se salgan y Vuelvan a Entrar Al Servidor tendarán que iniciar sesión con su nombre de usuario y contraseña.ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ⚠️🎃Importantes No Olvides Tu Nombre De Usuario Y Contraseña.",
        cover_image: "./img/Registre.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/IilYSoH4TtS",
        tags: ["Login", "Registre", "Seguridad"],
        last_updated: "2025-10-5",
        file_size: "2.16 MB"
    },
    {
        id: 6,
        title: "Rank Chat V9.4",
        description: "⚜️!🎃Rango chat Para Minecraft Bedrock Se Añadió Un Menu UI Pará Manejar El Systema De Rango En El Chat Con Facilidad El Menu Solamente Puede Ingresar Los Administradores Con Un Tag : ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ 🗂️🎃Último Agregado : Se Añadió Un Item Custom Qué Solo Se Puede Sacar del Creativo Y Abrilo Es Obligatorio Añadirte Un Tag /tag @s add Admin !",
        cover_image: "./img/Rango.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/Wlpks",
        tags: ["Rangos", "Menu UI", "Servidores"],
        last_updated: "2025-10-5",
        file_size: "360.04 KB"
    },
    {
        id: 7,
        title: "Menú Warp V9.9",
        description: "🔰!🎃Se Arreglaron Bug Este añade un Menu Warp con el que podras tener varias opciones para tu Realm Y Tu Servidor Puedes añadir este Menu Warp para utilizar varias opciones como las Warp, Clanes, Bank, Sethome, Trabajos entre otras opciones mas que puedes modificar en el > Confi < Descarga el Addon Aqui.",
        cover_image: "./img/MenuWarp.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/He9nBZqB7mEA",
        tags: ["Menu UI", "Banco", "Perfil", "Clanes","Trabajo"],
        last_updated: "2025-10-5",
        file_size: "312.11 KB"
    },
    {
        id: 8,
        title: "$1 Custom NPC V4.4",
        description: "⚙️!🎃CustomNPC Para Minecraft Bedrock Funciona Perfecto y tine Varios Utilidades, Este addon de NPC Custom puede ayudarte en tu servidor de Minecraft y puedes encontrar utilidades y la forma de editar y personalizar estos NPC para tu servidor de Minecraft o Realm o simplemente para tu servidor.",
        cover_image: "./img/Npc.jpg",
        version: "1.21.111",
        download_link: "https://cuty.io/FQcTTU",
        tags: ["Npc", "Custom", "Addon"],
        last_updated: "2025-10-5",
        file_size: "1 MB"
    }
];

// Configuración de JSONBin.io - TUS CREDENCIALES
const JSONBIN_BASE_URL = "https://api.jsonbin.io/v3/b";
const BIN_ID = "68e3f94dd0ea881f40978bff";
const MASTER_KEY = "$2a$10$llDNWie9.N2CafYjo7o3.OB/8XZpTocfzmyU2gCwG/bJGYAThWYyC";

// Configuración del sistema de cache
const CACHE_CONFIG = {
    REVIEWS_CACHE_KEY: 'edwardmc_reviews_cache',
    CACHE_TIMESTAMP_KEY: 'edwardmc_cache_timestamp',
    CACHE_DURATION: 5 * 60 * 1000, // 5 minutos en milisegundos
    PENDING_REVIEWS_KEY: 'edwardmc_pending_reviews'
};

// Sistema de cache para reseñas
class ReviewsCache {
    constructor() {
        this.isOnline = true;
        this.pendingSync = this.getPendingReviews();
        this.init();
    }

    init() {
        // Verificar conexión
        this.checkConnection();
        // Sincronizar pendientes al cargar
        this.syncPendingReviews();
    }

    // Verificar si el cache está vigente
    isCacheValid() {
        const timestamp = localStorage.getItem(CACHE_CONFIG.CACHE_TIMESTAMP_KEY);
        if (!timestamp) return false;
        
        const now = Date.now();
        const cacheTime = parseInt(timestamp);
        return (now - cacheTime) < CACHE_CONFIG.CACHE_DURATION;
    }

    // Guardar reseñas en cache
    saveToCache(reviews) {
        try {
            localStorage.setItem(CACHE_CONFIG.REVIEWS_CACHE_KEY, JSON.stringify(reviews));
            localStorage.setItem(CACHE_CONFIG.CACHE_TIMESTAMP_KEY, Date.now().toString());
            console.log('Reseñas guardadas en cache local');
        } catch (error) {
            console.error('Error guardando en cache:', error);
        }
    }

    // Obtener reseñas del cache
    getFromCache() {
        try {
            const cached = localStorage.getItem(CACHE_CONFIG.REVIEWS_CACHE_KEY);
            return cached ? JSON.parse(cached) : null;
        } catch (error) {
            console.error('Error obteniendo del cache:', error);
            return null;
        }
    }

    // Guardar reseña pendiente de sincronización
    savePendingReview(addonId, rating, comment) {
        const pending = this.getPendingReviews();
        const review = {
            addonId,
            rating,
            comment,
            timestamp: new Date().toISOString(),
            userId: getUserId()
        };
        
        pending.push(review);
        localStorage.setItem(CACHE_CONFIG.PENDING_REVIEWS_KEY, JSON.stringify(pending));
        return review;
    }

    // Obtener reseñas pendientes
    getPendingReviews() {
        try {
            const pending = localStorage.getItem(CACHE_CONFIG.PENDING_REVIEWS_KEY);
            return pending ? JSON.parse(pending) : [];
        } catch (error) {
            console.error('Error obteniendo reseñas pendientes:', error);
            return [];
        }
    }

    // Limpiar reseñas pendientes
    clearPendingReviews() {
        localStorage.removeItem(CACHE_CONFIG.PENDING_REVIEWS_KEY);
    }

    // Sincronizar reseñas pendientes con JSONBin
    async syncPendingReviews() {
        const pending = this.getPendingReviews();
        if (pending.length === 0 || !this.isOnline) return;

        console.log(`Sincronizando ${pending.length} reseñas pendientes...`);
        
        for (const review of pending) {
            try {
                await this.syncSingleReview(review);
            } catch (error) {
                console.error('Error sincronizando reseña:', error);
                break; // Si falla una, paramos para no perder las demás
            }
        }

        // Actualizar cache después de sincronizar
        await this.fetchAndUpdateCache();
    }

    // Sincronizar una sola reseña
    async syncSingleReview(review) {
        const reviews = await this.fetchReviewsFromAPI();
        
        if (!reviews[review.addonId]) {
            reviews[review.addonId] = [];
        }

        const existingIndex = reviews[review.addonId].findIndex(r => r.userId === review.userId);
        
        if (existingIndex !== -1) {
            reviews[review.addonId][existingIndex] = {
                userId: review.userId,
                rating: review.rating,
                comment: review.comment,
                timestamp: review.timestamp
            };
        } else {
            reviews[review.addonId].push({
                userId: review.userId,
                rating: review.rating,
                comment: review.comment,
                timestamp: review.timestamp
            });
        }

        await this.saveReviewsToAPI(reviews);
    }

    // Verificar conexión a internet
    checkConnection() {
        this.isOnline = navigator.onLine;
        
        // Escuchar cambios en la conexión
        window.addEventListener('online', () => {
            this.isOnline = true;
            this.syncPendingReviews();
        });
        
        window.addEventListener('offline', () => {
            this.isOnline = false;
        });
    }

    // Obtener reseñas (con cache)
    async getReviews() {
        // Primero intentar con cache válido
        if (this.isCacheValid()) {
            const cached = this.getFromCache();
            if (cached) {
                console.log('Usando reseñas desde cache local');
                return cached;
            }
        }

        // Si no hay cache válido, obtener de API
        return await this.fetchAndUpdateCache();
    }

    // Obtener reseñas desde API y actualizar cache
    async fetchAndUpdateCache() {
        try {
            const reviews = await this.fetchReviewsFromAPI();
            this.saveToCache(reviews);
            console.log('Reseñas actualizadas desde JSONBin');
            return reviews;
        } catch (error) {
            console.error('Error obteniendo reseñas:', error);
            // Si falla la API, usar cache aunque sea viejo
            const cached = this.getFromCache();
            if (cached) {
                console.log('Usando cache antiguo por fallo de conexión');
                return cached;
            }
            throw error;
        }
    }

    // Obtener reseñas desde JSONBin
    async fetchReviewsFromAPI() {
        const response = await fetch(`${JSONBIN_BASE_URL}/${BIN_ID}/latest`, {
            headers: {
                'X-Master-Key': MASTER_KEY,
                'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) {
            throw new Error('Error al cargar las reseñas desde JSONBin');
        }
        
        const data = await response.json();
        return data.record || this.getDefaultReviewsStructure();
    }

    // Guardar reseñas en JSONBin
    async saveReviewsToAPI(reviews) {
        const response = await fetch(`${JSONBIN_BASE_URL}/${BIN_ID}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-Master-Key': MASTER_KEY
            },
            body: JSON.stringify(reviews)
        });
        
        if (!response.ok) {
            throw new Error('Error al guardar las reseñas en JSONBin');
        }
        
        return await response.json();
    }

    // Estructura por defecto para reseñas
    getDefaultReviewsStructure() {
        return {
            "1": [],
            "2": [],
            "3": [],
            "4": [],
            "5": [],
            "6": [],
            "7": [],
            "8": []
        };
    }
}

// Instancia global del cache
const reviewsCache = new ReviewsCache();

// Sistema de carga
function showLoading() {
    const loadingOverlay = document.getElementById('loadingOverlay');
    if (loadingOverlay) {
        loadingOverlay.classList.remove('hidden');
    }
}

function hideLoading() {
    const loadingOverlay = document.getElementById('loadingOverlay');
    if (loadingOverlay) {
        setTimeout(() => {
            loadingOverlay.classList.add('hidden');
        }, 1000);
    }
}

// Función para obtener un addon por ID
function getAddonById(id) {
    return addonsData.find(addon => addon.id === parseInt(id));
}

// Función para obtener todos los addons
function getAllAddons() {
    return addonsData;
}

// Función para buscar addons
function searchAddons(query) {
    if (!query) {
        return addonsData;
    }
    
    const lowerQuery = query.toLowerCase();
    return addonsData.filter(addon => 
        addon.title.toLowerCase().includes(lowerQuery) ||
        addon.description.toLowerCase().includes(lowerQuery) ||
        addon.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
    );
}

// Función para formatear fechas
function formatDate(dateString) {
    const options = { year: 'numeric', month: 'long', day: 'numeric' };
    return new Date(dateString).toLocaleDateString('es-ES', options);
}

// Sistema de reseñas (ACTUALIZADO con cache)
async function fetchReviews() {
    return await reviewsCache.getReviews();
}

async function saveReviews(reviews) {
    try {
        await reviewsCache.saveReviewsToAPI(reviews);
        reviewsCache.saveToCache(reviews); // Actualizar cache local
        return reviews;
    } catch (error) {
        console.error('Error al guardar reseñas:', error);
        throw error;
    }
}

// Obtener reseñas de un addon específico
async function getReviewsForAddon(addonId) {
    const reviews = await fetchReviews();
    return reviews[addonId] || [];
}

// Obtener reseña del usuario actual para un addon
async function getUserReviewForAddon(addonId) {
    const reviews = await getReviewsForAddon(addonId);
    const userId = getUserId();
    
    // También verificar en reseñas pendientes
    const pending = reviewsCache.getPendingReviews();
    const pendingReview = pending.find(review => 
        review.addonId === addonId.toString() && review.userId === userId
    );
    
    if (pendingReview) {
        return {
            userId: pendingReview.userId,
            rating: pendingReview.rating,
            comment: pendingReview.comment,
            timestamp: pendingReview.timestamp,
            pending: true
        };
    }
    
    return reviews.find(review => review.userId === userId);
}

// Añadir o actualizar reseña (ACTUALIZADA con sistema de cache)
async function addOrUpdateReview(addonId, rating, comment) {
    const userId = getUserId();
    
    if (reviewsCache.isOnline) {
        // Si hay conexión, guardar directamente en JSONBin
        const reviews = await fetchReviews();
        
        if (!reviews[addonId]) {
            reviews[addonId] = [];
        }
        
        const existingReviewIndex = reviews[addonId].findIndex(review => review.userId === userId);
        
        if (existingReviewIndex !== -1) {
            reviews[addonId][existingReviewIndex] = {
                userId,
                rating,
                comment,
                timestamp: new Date().toISOString()
            };
        } else {
            reviews[addonId].push({
                userId,
                rating,
                comment,
                timestamp: new Date().toISOString()
            });
        }
        
        await saveReviews(reviews);
        return reviews[addonId];
    } else {
        // Sin conexión, guardar en cache local como pendiente
        console.log('Sin conexión, guardando reseña en cache local');
        reviewsCache.savePendingReview(addonId.toString(), rating, comment);
        
        // Actualizar cache local para reflejar el cambio inmediatamente
        const cachedReviews = reviewsCache.getFromCache() || reviewsCache.getDefaultReviewsStructure();
        if (!cachedReviews[addonId]) {
            cachedReviews[addonId] = [];
        }
        
        const existingIndex = cachedReviews[addonId].findIndex(review => review.userId === userId);
        
        if (existingIndex !== -1) {
            cachedReviews[addonId][existingIndex] = {
                userId,
                rating,
                comment,
                timestamp: new Date().toISOString()
            };
        } else {
            cachedReviews[addonId].push({
                userId,
                rating,
                comment,
                timestamp: new Date().toISOString()
            });
        }
        
        reviewsCache.saveToCache(cachedReviews);
        return cachedReviews[addonId];
    }
}

// Eliminar reseña (ACTUALIZADA con sistema de cache)
async function deleteReview(addonId) {
    const userId = getUserId();
    
    if (reviewsCache.isOnline) {
        const reviews = await fetchReviews();
        
        if (reviews[addonId]) {
            reviews[addonId] = reviews[addonId].filter(review => review.userId !== userId);
            await saveReviews(reviews);
        }
        
        return reviews[addonId] || [];
    } else {
        // Sin conexión, eliminar de cache local
        console.log('Sin conexión, eliminando reseña del cache local');
        
        // Eliminar de pendientes
        const pending = reviewsCache.getPendingReviews().filter(review => 
            !(review.addonId === addonId.toString() && review.userId === userId)
        );
        localStorage.setItem(CACHE_CONFIG.PENDING_REVIEWS_KEY, JSON.stringify(pending));
        
        // Actualizar cache local
        const cachedReviews = reviewsCache.getFromCache() || reviewsCache.getDefaultReviewsStructure();
        if (cachedReviews[addonId]) {
            cachedReviews[addonId] = cachedReviews[addonId].filter(review => review.userId !== userId);
            reviewsCache.saveToCache(cachedReviews);
        }
        
        return cachedReviews[addonId] || [];
    }
}

// Forzar sincronización de reseñas
async function forceSyncReviews() {
    if (!reviewsCache.isOnline) {
        console.log('No hay conexión para sincronizar');
        return false;
    }
    
    try {
        await reviewsCache.syncPendingReviews();
        reviewsCache.clearPendingReviews();
        console.log('Sincronización completada');
        return true;
    } catch (error) {
        console.error('Error en sincronización:', error);
        return false;
    }
}

// Calcular promedio de calificaciones
function calculateAverageRating(reviews) {
    if (!reviews || reviews.length === 0) return 0;
    
    const sum = reviews.reduce((total, review) => total + review.rating, 0);
    return (sum / reviews.length).toFixed(1);
}

// Generar ID único para usuario (simulado)
function getUserId() {
    let userId = localStorage.getItem('edwardmc_userId');
    if (!userId) {
        userId = 'user_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('edwardmc_userId', userId);
    }
    return userId;
}

// Renderizar estrellas
function renderStars(rating, interactive = false, size = 'medium') {
    const starSize = size === 'small' ? '1rem' : '1.5rem';
    let starsHtml = '';
    
    for (let i = 1; i <= 5; i++) {
        if (interactive) {
            starsHtml += `
                <span class="star ${i <= rating ? 'active' : ''}" data-rating="${i}">
                    <svg xmlns="http://www.w3.org/2000/svg" width="${starSize}" height="${starSize}" viewBox="0 0 24 24" fill="${i <= rating ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                    </svg>
                </span>
            `;
        } else {
            starsHtml += `
                <span class="star ${i <= rating ? 'active' : ''}">
                    <svg xmlns="http://www.w3.org/2000/svg" width="${starSize}" height="${starSize}" viewBox="0 0 24 24" fill="${i <= rating ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                    </svg>
                </span>
            `;
        }
    }
    
    return `<div class="stars ${interactive ? 'interactive' : ''} ${size}">${starsHtml}</div>`;
}

// Función para obtener foto de perfil del usuario
function getUserProfilePicture() {
    return "./img/profile/p1.jpg";
}

// Función para procesar texto con stickers (compatibilidad)
function processTextWithStickers(text) {
    if (typeof window.StickerSystem !== 'undefined') {
        return window.StickerSystem.processStickers(text);
    }
    return text;
}

// Función para procesar texto con stickers en títulos (compatibilidad)
function processTextWithStickersInTitles(text) {
    if (typeof window.StickerSystem !== 'undefined') {
        return window.StickerSystem.processStickersInTitles(text);
    }
    return text;
}

// Sincronizar automáticamente al cargar la página si hay conexión
document.addEventListener('DOMContentLoaded', function() {
    if (reviewsCache.isOnline) {
        // Sincronizar pendientes después de 2 segundos
        setTimeout(() => {
            reviewsCache.syncPendingReviews();
        }, 2000);
    }
    
    // Mostrar estado de conexión en consola
    console.log(`Estado conexión: ${reviewsCache.isOnline ? 'En línea' : 'Sin conexión'}`);
    
    const pending = reviewsCache.getPendingReviews();
    if (pending.length > 0) {
        console.log(`${pending.length} reseñas pendientes de sincronización`);
    }
});
